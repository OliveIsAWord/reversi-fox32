extern fn millis() usize

const STONE_MOVE  = 0b00_u8 # empty square, can place a stone here
const STONE_EMPTY = 0b01_u8 # empty square, cannot place a stone here
const STONE_BLACK = 0b10_u8 # square with a black stone
const STONE_WHITE = 0b11_u8 # square with a white stone

const WINDOW_WIDTH = 255
const WINDOW_HEIGHT = 255

const COLOR_BACKGROUND = 0x6688aa
const COLOR_EDGE = 0x334466
const COLOR_BLACK = 0x222233
const COLOR_WHITE = 0xffeebb

fn color(anon bytes: usize) Color:
    Color(
        r: (bytes >> 16) as u8
        g: (bytes >> 8) as u8
        b: bytes as u8
        a: 0xff_u8
    )

fn draw_vertical_line_to_overlay(x: usize, y: usize, height: usize, color: Color, overlay: u8):
    draw_filled_rectangle_to_overlay(:x, :y, width: 1, :height, :color, :overlay)
    
fn draw_horizontal_line_to_overlay(x: usize, y: usize, width: usize, color: Color, overlay: u8):
    draw_filled_rectangle_to_overlay(:x, :y, :width, height: 1, :color, :overlay)

# x and y are the center of the circle
fn draw_circle_to_overlay(x: usize, y: usize, radius: usize, color: Color, overlay: u8):
    let mut y1 = y - radius
    while y1 <= y + radius:
        defer y1 = y1 + 1
        let mut x1 = x - radius
        while x1 <= x + radius:
            defer x1 = x1 + 1
            let x_center = x - x1
            let y_center = y - y1
            # using `<` instead of `<=` here makes more visually appealing circles, i think
            if x_center * x_center + y_center * y_center < radius * radius:
                draw_pixel_to_overlay(x: x1, y: y1, :color, :overlay)

struct App:
    window: Window^mut
    # Each row of the board is a `u16` conceptually split into eight 2-bit chunks each storing a STONE_*.
    board: u16[8]
    # false - black to move, true - white to move
    turn: bool

fn new_app(window: Window^mut) App:
    let mut board = (null() as u16[8]^)^
    let mut i = 0
    while i < 8:
        defer i = i + 1
        board@mut[i] = 0_u16
    let mut app = App(:window, :board, turn: false)
    init_app(app@mut)
    app

fn init_app(anon _: App^mut):
    .set_stone(x: 3_u8, y: 3_u8, stone: STONE_WHITE)
    .set_stone(x: 4_u8, y: 3_u8, stone: STONE_BLACK)
    .set_stone(x: 3_u8, y: 4_u8, stone: STONE_BLACK)
    .set_stone(x: 4_u8, y: 4_u8, stone: STONE_WHITE)
    .calculate_moves()
    self^@.clear_display()
    self^@.display_app()

fn get_stone(anon _: App^, x: u8, y: u8) u8:
    assert(x < 8_u8, "x out of bounds")
    assert(y < 8_u8, "y out of bounds")
    let stone = (self^.board@[y as usize] >> (x as u16 * 2_u16)) as u8 & 3_u8
    assert(stone <= 3_u8, "corrupted stone")
    stone

fn set_stone(anon _: App^mut, x: u8, y: u8, stone: u8):
    assert(x < 8_u8, "x out of bounds")
    assert(y < 8_u8, "y out of bounds")
    assert(stone <= 3_u8, "corrupted stone")
    let row = self^.board@mut[y as usize]@mut
    let x = (x * 2_u8) as u16
    row^ = row^ & (0xFFFF_u16 - 0b11_u16 << x) | stone as u16 << x

fn calculate_moves(anon _: App^mut):
    0

fn clear_display(anon _: App^):
    let background_color = color(COLOR_BACKGROUND)
    let edge_color = color(COLOR_EDGE)
    self^.window.fill_window(background_color)
    let overlay = self^.window^.overlay
    let mut i = 31
    while i < WINDOW_WIDTH:
        draw_vertical_line_to_overlay(x: i, y: 16, height: WINDOW_HEIGHT, color: edge_color, :overlay)
        draw_horizontal_line_to_overlay(x: 0, y: i + 16, width: WINDOW_WIDTH, color: edge_color, :overlay)
        i = i + 32

fn display_app(anon _: App^):
    let black_color = color(COLOR_BLACK)
    let white_color = color(COLOR_WHITE)
    let overlay = self^.window^.overlay
    # let start = millis()
    let mut x = 0_u8
    while x < 8_u8:
        defer x = x + 1_u8
        let mut y = 0_u8
        while y < 8_u8:
            defer y = y + 1_u8
            let stone = .get_stone(:x, :y)
            if stone != STONE_EMPTY:
                let color = if stone == STONE_WHITE:
                    white_color
                else if stone == STONE_MOVE:
                    color(0xff00ff)
                else:
                    black_color
                draw_circle_to_overlay(
                    x: 32 * x as usize + 15
                    y: 32 * y as usize + 31
                    radius: 13
                    :color
                    :overlay
                )
    # let end = millis()
    # draw_decimal_to_overlay(
    #     value: end - start
    #     x: 42
    #     y: 69
    #     foreground_color: 0xffff_ffff_u32
    #     background_color: 0xff00_0000_u32
    #     :overlay
    # )

fn handle_mouse_click(anon _: App^mut, x: usize, y: usize):
    let x = (x / 32) as u8
    let y = ((y - 16) / 32) as u8
    if self^@.get_stone(:x, :y) == STONE_MOVE:
        let stone = if self^.turn:
            self^.turn = false
            STONE_WHITE
        else:
            self^.turn = true
            STONE_BLACK
        .set_stone(:x, :y, :stone)
        self^@.display_app()

fn close_app(anon _: App^mut): 0

fn main():
    let mut window = (null() as Window^)^
    let window = window@mut
    window.new_window(
        title: "Reversi"
        width: WINDOW_WIDTH as u16
        height: WINDOW_HEIGHT as u16
        x: 100_u16
        y: 50_u16
        menu_bar: null()
        widgets: null()
    )
    defer window.destroy_window()

    let mut app = new_app(:window)
    let app = app@mut
    defer app.close_app()

    let mut running = true
    while running:
        yield_task()
        let mut event = Event(kind: EVENT_TYPE_MOUSE_CLICK, parameters: (null() as usize[7]^)^)
        while event.kind != EVENT_TYPE_EMPTY:
            event = window.get_next_window_event()
            if event.kind == EVENT_TYPE_MOUSE_CLICK:
                let x = event.parameters@[0]
                let y = event.parameters@[1]
                if y < 16:
                    if x < 8:
                        running = false
                    else:
                        window.start_dragging_window()
                else:
                    app.handle_mouse_click(:x, :y)
            else if event.kind == EVENT_TYPE_KEY_DOWN:
                let key = event.parameters@[0]
                if key == KEY_LSHIFT or key == KEY_RSHIFT:
                    shift_pressed()
                else if key == KEY_CAPS:
                    caps_pressed()
            else if event.kind == EVENT_TYPE_KEY_UP:
                let key = event.parameters@[0]
                if key == KEY_LSHIFT or key == KEY_RSHIFT:
                    shift_released()
