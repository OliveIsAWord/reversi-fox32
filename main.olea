extern fn millis() usize

const STONE_PLACE  = 0b00_u8 # empty square, can place a stone here
const STONE_EMPTY = 0b01_u8 # empty square, cannot place a stone here
const STONE_BLACK = 0b10_u8 # square with a black stone
const STONE_WHITE = 0b11_u8 # square with a white stone

const WINDOW_WIDTH = 255
const WINDOW_HEIGHT = 255

const COLOR_BACKGROUND = 0x6688aa
const COLOR_EDGE = 0x334466
const COLOR_BLACK = 0x222233
const COLOR_WHITE = 0xffeebb

fn color(anon bytes: usize) Color:
    Color(
        r: (bytes >> 16) as u8
        g: (bytes >> 8) as u8
        b: bytes as u8
        a: 0xff_u8
    )

fn draw_vertical_line_to_overlay(_, x: usize, y: usize, height: usize, color: Color, overlay: u8):
    draw_filled_rectangle_to_overlay(:x, :y, width: 1, :height, :color, :overlay)
    
fn draw_horizontal_line_to_overlay(_, x: usize, y: usize, width: usize, color: Color, overlay: u8):
    draw_filled_rectangle_to_overlay(:x, :y, :width, height: 1, :color, :overlay)

# x and y are the center of the circle
fn draw_circle_to_overlay(_, x: usize, y: usize, radius: usize, color: Color, overlay: u8):
    let mut y1 = y - radius
    while y1 <= y + radius:
        defer y1 = y1 + 1
        let mut x1 = x - radius
        while x1 <= x + radius:
            defer x1 = x1 + 1
            let x_center = x - x1
            let y_center = y - y1
            # using `<` instead of `<=` here makes more visually appealing circles, i think
            if x_center * x_center + y_center * y_center < radius * radius:
                draw_pixel_to_overlay(x: x1, y: y1, :color, :overlay)

struct App:
    window: Window^mut
    # Each row of the board is a `u16` conceptually split into eight 2-bit chunks each storing a STONE_*.
    board: u16[8]
    # false - black to move, true - white to move
    turn: bool

fn new_app(window: Window^mut) App:
    let mut board = (null() as u16[8]^)^
    let mut i = 0
    while i < 8:
        defer i = i + 1
        board@mut[i] = 0_u16
    let mut app = App(:window, :board, turn: false)
    init_app(app@mut)
    app

fn init_app(anon _: App^mut):
    .set_stone(x: 3_u8, y: 3_u8, stone: STONE_WHITE)
    .set_stone(x: 4_u8, y: 3_u8, stone: STONE_BLACK)
    .set_stone(x: 3_u8, y: 4_u8, stone: STONE_BLACK)
    .set_stone(x: 4_u8, y: 4_u8, stone: STONE_WHITE)
    .calculate_moves()
    self^@.clear_display()
    self^@.display_app()

fn get_stone(anon _: App^, x: u8, y: u8) u8:
    assert(x < 8_u8, "x out of bounds")
    assert(y < 8_u8, "y out of bounds")
    let stone = (self^.board@[y as usize] >> (x as u16 * 2_u16)) as u8 & 3_u8
    assert(stone <= 3_u8, "corrupted stone")
    stone

fn set_stone(anon _: App^mut, x: u8, y: u8, stone: u8):
    assert(x < 8_u8, "x out of bounds")
    assert(y < 8_u8, "y out of bounds")
    assert(stone <= 3_u8, "corrupted stone")
    let row = self^.board@mut[y as usize]@mut
    let x = (x * 2_u8) as u16
    row^ = row^ & (0xFFFF_u16 - 0b11_u16 << x) | stone as u16 << x

fn calculate_moves(anon _: App^mut):
    let mut x = 0_u8
    while x < 8_u8:
        defer x = x + 1_u8
        let mut y = 0_u8
        while y < 8_u8:
            defer y = y + 1_u8
            if self^@.get_stone(:x, :y) & 2_u8 == 0_u8:
                .set_stone(:x, :y, stone: STONE_EMPTY)
                .calculate_moves0(:x, :y, dx: 1_u8, dy: 0_u8)
                .calculate_moves0(:x, :y, dx: 1_u8, dy: -1_u8)
                .calculate_moves0(:x, :y, dx: 0_u8, dy: -1_u8)
                .calculate_moves0(:x, :y, dx: -1_u8, dy: -1_u8)
                .calculate_moves0(:x, :y, dx: -1_u8, dy: 0_u8)
                .calculate_moves0(:x, :y, dx: -1_u8, dy: 1_u8)
                .calculate_moves0(:x, :y, dx: 0_u8, dy: 1_u8)
                .calculate_moves0(:x, :y, dx: 1_u8, dy: 1_u8)

fn calculate_moves0(anon _: App^mut, x: u8, y: u8, dx: u8, dy: u8):
    let enemy_stone = if self^.turn:
        STONE_BLACK
    else:
        STONE_WHITE
    let mut nx = x + dx
    let mut ny = y + dy
    let mut can_place_here = false
    while 0_u8 <= nx < 8_u8
        and 0_u8 <= ny < 8_u8
        and self^@.get_stone(x: nx, y: ny) == enemy_stone:
        nx = nx + dx
        ny = ny + dy
        can_place_here = true
    if can_place_here
        and 0_u8 <= nx < 8_u8
        and 0_u8 <= ny < 8_u8
        and self^@.get_stone(x: nx, y: ny) & 2_u8 != 0_u8:
        .set_stone(:x, :y, stone: STONE_PLACE)

fn make_move(anon _: App^mut, x: u8, y: u8):
    defer self^.turn = if self^.turn:
        false
    else:
        true
    let stone = if self^.turn:
        STONE_WHITE
    else:
        STONE_BLACK
    .set_stone(:x, :y, :stone)
    .make_move0(:x, :y, dx: 1_u8, dy: 0_u8)
    .make_move0(:x, :y, dx: 1_u8, dy: -1_u8)
    .make_move0(:x, :y, dx: 0_u8, dy: -1_u8)
    .make_move0(:x, :y, dx: -1_u8, dy: -1_u8)
    .make_move0(:x, :y, dx: -1_u8, dy: 0_u8)
    .make_move0(:x, :y, dx: -1_u8, dy: 1_u8)
    .make_move0(:x, :y, dx: 0_u8, dy: 1_u8)
    .make_move0(:x, :y, dx: 1_u8, dy: 1_u8)

fn make_move0(anon _: App^mut, x: u8, y: u8, dx: u8, dy: u8):
    let stone = if self^.turn:
        STONE_WHITE
    else:
        STONE_BLACK

    let enemy_stone = if self^.turn:
        STONE_BLACK
    else:
        STONE_WHITE
    let mut nx = x + dx
    let mut ny = y + dy
    while 0_u8 <= nx < 8_u8
        and 0_u8 <= ny < 8_u8
        and self^@.get_stone(x: nx, y: ny) == enemy_stone:
        nx = nx + dx
        ny = ny + dy
    if 0_u8 <= nx < 8_u8
        and 0_u8 <= ny < 8_u8
        and self^@.get_stone(x: nx, y: ny) == stone:
        nx = nx - dx
        ny = ny - dy
        while self^@.get_stone(x: nx, y: ny) == enemy_stone:
            defer:
                nx = nx - dx
                ny = ny - dy
            .set_stone(x: nx, y: ny, :stone)

fn clear_display(anon _: App^):
    let background_color = color(COLOR_BACKGROUND)
    let edge_color = color(COLOR_EDGE)
    self^.window.fill_window(background_color)
    let overlay = self^.window^.overlay
    let mut i = 31
    while i < WINDOW_WIDTH:
        draw_vertical_line_to_overlay(x: i, y: 16, height: WINDOW_HEIGHT, color: edge_color, :overlay)
        draw_horizontal_line_to_overlay(x: 0, y: i + 16, width: WINDOW_WIDTH, color: edge_color, :overlay)
        i = i + 32

fn display_app(anon _: App^):
    let background_color = color(COLOR_BACKGROUND)
    let black_color = color(COLOR_BLACK)
    let white_color = color(COLOR_WHITE)
    let overlay = self^.window^.overlay
    # let start = millis()
    let mut x = 0_u8
    while x < 8_u8:
        defer x = x + 1_u8
        let mut y = 0_u8
        while y < 8_u8:
            defer y = y + 1_u8
            let stone = .get_stone(:x, :y)
            let color = if stone == STONE_WHITE:
                 white_color
            else if stone == STONE_BLACK:
                black_color
            else if stone == STONE_PLACE:
                color(0xff00ff)
            else:
                background_color
            draw_circle_to_overlay(
                x: 32 * x as usize + 15
                y: 32 * y as usize + 31
                radius: 13
                :color
                :overlay
            )
            yield_task()
    # let end = millis()
    # draw_decimal_to_overlay(
    #     value: end - start
    #     x: 42
    #     y: 69
    #     foreground_color: 0xffff_ffff_u32
    #     background_color: 0xff00_0000_u32
    #     :overlay
    # )

fn handle_mouse_click(anon _: App^mut, x: usize, y: usize):
    let x = (x / 32) as u8
    let y = (y / 32) as u8
    if self^@.get_stone(:x, :y) == STONE_PLACE:
        .make_move(:x, :y)
        .calculate_moves()
        self^@.display_app()

fn close_app(anon _: App^mut): 0

fn main():
    let mut window = (null() as Window^)^
    let window = window@mut
    window.new_window(
        title: "Reversi"
        width: WINDOW_WIDTH as u16
        height: WINDOW_HEIGHT as u16
        x: 100_u16
        y: 50_u16
        menu_bar: null()
        widgets: null()
    )
    defer window.destroy_window()

    let mut app = new_app(:window)
    let app = app@mut
    defer app.close_app()

    let mut running = true
    while running:
        yield_task()
        let mut event = Event(kind: EVENT_TYPE_MOUSE_CLICK, parameters: (null() as usize[7]^)^)
        while event.kind != EVENT_TYPE_EMPTY:
            event = window.get_next_window_event()
            if event.kind == EVENT_TYPE_MOUSE_CLICK:
                let x = event.parameters@[0]
                let y = event.parameters@[1]
                if y < 16:
                    if x < 8:
                        running = false
                    else:
                        window.start_dragging_window()
                else:
                    app.handle_mouse_click(:x, y: y - 16)
            else if event.kind == EVENT_TYPE_KEY_DOWN:
                let key = event.parameters@[0]
                if key == KEY_LSHIFT or key == KEY_RSHIFT:
                    shift_pressed()
                else if key == KEY_CAPS:
                    caps_pressed()
            else if event.kind == EVENT_TYPE_KEY_UP:
                let key = event.parameters@[0]
                if key == KEY_LSHIFT or key == KEY_RSHIFT:
                    shift_released()
